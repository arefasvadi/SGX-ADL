// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CMAC128_H_
#define FLATBUFFERS_GENERATED_CMAC128_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 11 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

struct CMAC128Auth;
struct CMAC128AuthBuilder;

struct CMAC128Auth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CMAC128AuthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4,
    VT_AAD = 6,
    VT_MAC = 8
  };
  const flatbuffers::Vector<uint8_t> *content() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  flatbuffers::Vector<uint8_t> *mutable_content() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  const flatbuffers::Vector<uint8_t> *aad() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AAD);
  }
  flatbuffers::Vector<uint8_t> *mutable_aad() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_AAD);
  }
  const flatbuffers::Vector<uint8_t> *mac() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MAC);
  }
  flatbuffers::Vector<uint8_t> *mutable_mac() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MAC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyOffsetRequired(verifier, VT_AAD) &&
           verifier.VerifyVector(aad()) &&
           VerifyOffsetRequired(verifier, VT_MAC) &&
           verifier.VerifyVector(mac()) &&
           verifier.EndTable();
  }
};

struct CMAC128AuthBuilder {
  typedef CMAC128Auth Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content) {
    fbb_.AddOffset(CMAC128Auth::VT_CONTENT, content);
  }
  void add_aad(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> aad) {
    fbb_.AddOffset(CMAC128Auth::VT_AAD, aad);
  }
  void add_mac(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mac) {
    fbb_.AddOffset(CMAC128Auth::VT_MAC, mac);
  }
  explicit CMAC128AuthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CMAC128Auth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CMAC128Auth>(end);
    fbb_.Required(o, CMAC128Auth::VT_CONTENT);
    fbb_.Required(o, CMAC128Auth::VT_AAD);
    fbb_.Required(o, CMAC128Auth::VT_MAC);
    return o;
  }
};

inline flatbuffers::Offset<CMAC128Auth> CreateCMAC128Auth(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> content = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> aad = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mac = 0) {
  CMAC128AuthBuilder builder_(_fbb);
  builder_.add_mac(mac);
  builder_.add_aad(aad);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<CMAC128Auth> CreateCMAC128AuthDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content = nullptr,
    const std::vector<uint8_t> *aad = nullptr,
    const std::vector<uint8_t> *mac = nullptr) {
  auto content__ = content ? _fbb.CreateVector<uint8_t>(*content) : 0;
  auto aad__ = aad ? _fbb.CreateVector<uint8_t>(*aad) : 0;
  auto mac__ = mac ? _fbb.CreateVector<uint8_t>(*mac) : 0;
  return CreateCMAC128Auth(
      _fbb,
      content__,
      aad__,
      mac__);
}

#endif  // FLATBUFFERS_GENERATED_CMAC128_H_
